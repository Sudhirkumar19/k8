# PV for EFS static provisioning. This PV will be used to create a claim for the EFS volume which will be used in the deployment manifest to mount the volume to the backend application. The PV will be created with the access mode ReadWriteMany because EFS volume can be attached to multiple nodes at the same time which is required for the backend application to access the data from multiple nodes. 

# the storage capcity of EPS in AWS is 47.9 TiB, so we can define the storage capacity of the PV as 47.9Ti or less than that.

apiVersion: v1
kind: PersistentVolume
metadta:
  name: expense-efs
spec:
  capacity:
    storage: 5Gi # here storage should be less than or equal to the storage capacity of the EFS volume created in AWS Cloud 
  volumeMode: Filesystem
  accessModes:
    - ReadWriteMany # in EFS volume can be attached to multiple nodes at the same time, so we need to use ReadWriteMany access mode to ensure that the volume can be attached to multiple nodes at the same time which is required for the backend application to access the data from multiple nodes. If you want to use ReadWriteOnce access mode then you need to use a different storage solution like EBS which supports single attachment.

  storageClassName: " " # here storageClassName should be empty string because we are using static provisioning. If you are using dynamic provisioning then you can define the storageClassName and use it in the pvc claim manifest to create the claim for the persistent volume. In that case you don't need to create the PV manually because it will be created automatically by kubernetes when the claim is created.
  persistentVolumeReclaimPolicy: Retain # here reclaim policy should be Retain because we don't want to delete the EFS volume when the claim is deleted. If you want to delete the EFS volume when the claim is deleted then you can change the reclaim policy to Delete. In that case you need to be careful while deleting the claim because it will delete the EFS volume and all the data stored in it will be lost.
  csi:
    driver: efs.csi.aws.com # here driver should be efs.csi.aws.com because we are using EFS volume. If you are using a different storage solution then you need to use the appropriate driver for that storage solution. For example, if you are using EBS volume then you need to use ebs.csi.aws.com driver.
    # here drivers are installed because we have installed the EFS CSI driver in the cluster using the command kubectl apply -k "github.com/kubernetes-sigs/aws-efs-csi-driver/deploy/kubernetes/overlays/stable/?ref=release-1.3" command. If you are using a different storage solution then you need to install the appropriate CSI driver for that storage solution in the cluster before creating the PV and PVC claim.
    # the need of csi drivers installation is to enable the communication between the Kubernetes cluster and the storage solution to provision and manage the volumes dynamically. The CSI drivers are responsible for provisioning the volumes, attaching and detaching the volumes to the nodes, and managing the lifecycle of the volumes. 

    volumeHandle: fs-0c1a2b3c4d5e6f7g # (give your created volume ID in AWS ) here volumeHandle should be same which we have created in EFS Volume in AWS Cloud. Change the volumeHandle to your EFS Volume ID which you have created in AWS Cloud. The volumeHandle is used by the CSI driver to identify the EFS volume to provision and manage the volumes dynamically.


---

#PVC claim manifest.yaml. This pvc claim will create a claim for the persistent volume created above. The claim will be used in the deployment manifest to mount the volume to the backend application.

# And always pvc should refer pv with volume name, not with storage class name because in static provisioning we are creating the PV manually and we are not using the storage class to provision the volume dynamically. So in that case we need to refer the PV with volume name in the pvc claim manifest to create the claim for the persistent volume. If you are using dynamic provisioning then you can refer the PV with storage class name in the pvc claim manifest to create the claim for the persistent volume because in dynamic provisioning the PV will be created automatically by kubernetes when the claim is created and it will be bound to the claim based on the storage class name defined in the claim manifest. 

apiVersion : v1
kind: PersistentVolumeClaim
metadat: 
  name: expense-efs
spec: 
  volumeName: expense-efs # here volumeName should be same which we have created in the PV manifest to create the claim for the persistent volume. If you are using dynamic provisioning then you can remove this line because the volume will be provisioned automatically by kubernetes when the claim is created and it will be bound to the claim based on the storage class name defined in the claim manifest.
  accessModes:
    - ReadWriteMany # in EFS volume can be attached to multiple nodes at the same time, so we need to use ReadWriteMany access mode to ensure that the volume can be attached to multiple nodes at the same time which is required for the backend application to access the data from multiple nodes. If you want to use ReadWriteOnce access mode then you need to use a different storage solution like EBS which supports single attachment.
  storageClassName: " " # here storageClassName should be empty string because we are using static provisioning. If you are using dynamic provisioning then you can define the storageClassName and use it in the pvc claim manifest to create the claim for the persistent volume. In that case you don't need to create the PV manually because it will be created automatically by kubernetes when the claim is created.
  resources:
    requests:
      storage: 5Gi # here storage should be less than or equal to the storage defined in the persistent volume above because the claim cannot request more storage than the capacity defined in the PV. If you are using dynamic provisioning then you can define the storage as per your requirement because the PV will be created automatically by kubernetes when the claim is created and it will be bound to the claim based on the storage class name defined in the claim manifest. In that case you need to make sure that the storage defined in the claim manifest is less than or equal to the storage capacity of the EFS volume created in AWS Cloud.

      