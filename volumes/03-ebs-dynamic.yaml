#pvc claim manifest.yaml. This pvc claim will create a claim for the persistent volume created above. The claim will be used in the deployment manifest to mount the volume to the backend application.

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: ebs-dynamic
spec:
  storageClassName: "expense-ebs" # here storageClassName should be same as the name of the StorageClass created in 02-ebs-sc.yaml file
 # volumeName: ebs-dynamic # here volumeName should be same as the name of the persistent volume created in 01-ebs-static.yaml file if you are using static provisioning. If you are using dynamic provisioning then you can remove this line because the volume will be provisioned automatically by kubernetes when the claim is created.
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 3Gi # here storage should be less than or equal to the storage defined in the persistent volume above

---

#pod manifest.yaml. This pod will use the pvc claim created above to mount the EBS volume to the backend application. The backend application will use the mounted volume to store the data.

apiVersion: v1
kind: Pod
metadata:
  name: ebs-dynamic
  labels:
    purpose: ebs-dynamic
    
spec:
  nodeselector:
    topology.kubernetes.io/zone: us-east-1d # here nodeselector should be same which we have defined in the persistent volume above to schedule the pod on the same node where the EBS volume is attached
  containers:
   - name: app
     image: centos
     volumeMounts: # docker run -v hostpath:containerpath
     - name: ebs-dynamic
       mountPath: /usr/share/nginx/html # here mountPath should be same which we have defined in the deployment manifest to mount the volume to the backend application
  volumes:
  - name: ebs-dynamic
    persistentVolumeClaim:
      claimName: ebs-dynamic # here claimName should be same which we have defined in the pvc claim manifest to create the claim for the persistent volume
---
 # service manifest.yaml. This service will expose the pod created above to the other pods in the same namespace or to external clients.

kind: Service
apiVersion: v1
metadata:
  name: nginx
spec:
  type: LoadBalancer
  selector:
    purpose: ebs-dynamic
  ports:
  - name: nginx-svc-port
    protocol: TCP
    port: 80 # service port
    targetport: 80 # container port defined in the pod manifest to expose the application running in the container to the service
    nodeport: 30007 # nodeport should be in the range of 30000-32767 to expose the service to external clients through the node port. This is optional if you want to expose the service only to other pods in the same namespace then you can remove this line. If you want to expose the service to external clients then you can keep this line and access the service through the node port defined here. You can also use LoadBalancer type service to expose the service to external clients without using node port. In that case you can remove this line and change the type to LoadBalancer.